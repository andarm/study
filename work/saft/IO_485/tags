!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AF_CAN	can.h	32;"	d
CAN_BCM	can.h	79;"	d
CAN_CTRLMODE_3_SAMPLES	can_netlink.h	90;"	d
CAN_CTRLMODE_BERR_REPORTING	can_netlink.h	92;"	d
CAN_CTRLMODE_LISTENONLY	can_netlink.h	89;"	d
CAN_CTRLMODE_LOOPBACK	can_netlink.h	88;"	d
CAN_CTRLMODE_ONE_SHOT	can_netlink.h	91;"	d
CAN_EFF_FLAG	can.h	38;"	d
CAN_EFF_MASK	can.h	44;"	d
CAN_ERROR_H	error.h	15;"	d
CAN_ERR_ACK	error.h	25;"	d
CAN_ERR_BUSERROR	error.h	27;"	d
CAN_ERR_BUSOFF	error.h	26;"	d
CAN_ERR_CRTL	error.h	22;"	d
CAN_ERR_CRTL_RX_OVERFLOW	error.h	36;"	d
CAN_ERR_CRTL_RX_PASSIVE	error.h	40;"	d
CAN_ERR_CRTL_RX_WARNING	error.h	38;"	d
CAN_ERR_CRTL_TX_OVERFLOW	error.h	37;"	d
CAN_ERR_CRTL_TX_PASSIVE	error.h	41;"	d
CAN_ERR_CRTL_TX_WARNING	error.h	39;"	d
CAN_ERR_CRTL_UNSPEC	error.h	35;"	d
CAN_ERR_DLC	error.h	17;"	d
CAN_ERR_FLAG	can.h	40;"	d
CAN_ERR_LOSTARB	error.h	21;"	d
CAN_ERR_LOSTARB_UNSPEC	error.h	31;"	d
CAN_ERR_MASK	can.h	45;"	d
CAN_ERR_PROT	error.h	23;"	d
CAN_ERR_PROT_ACTIVE	error.h	53;"	d
CAN_ERR_PROT_BIT	error.h	47;"	d
CAN_ERR_PROT_BIT0	error.h	50;"	d
CAN_ERR_PROT_BIT1	error.h	51;"	d
CAN_ERR_PROT_FORM	error.h	48;"	d
CAN_ERR_PROT_LOC_ACK	error.h	73;"	d
CAN_ERR_PROT_LOC_ACK_DEL	error.h	74;"	d
CAN_ERR_PROT_LOC_CRC_DEL	error.h	72;"	d
CAN_ERR_PROT_LOC_CRC_SEQ	error.h	71;"	d
CAN_ERR_PROT_LOC_DATA	error.h	70;"	d
CAN_ERR_PROT_LOC_DLC	error.h	69;"	d
CAN_ERR_PROT_LOC_EOF	error.h	75;"	d
CAN_ERR_PROT_LOC_ID04_00	error.h	65;"	d
CAN_ERR_PROT_LOC_ID12_05	error.h	64;"	d
CAN_ERR_PROT_LOC_ID17_13	error.h	63;"	d
CAN_ERR_PROT_LOC_ID20_18	error.h	60;"	d
CAN_ERR_PROT_LOC_ID28_21	error.h	59;"	d
CAN_ERR_PROT_LOC_IDE	error.h	62;"	d
CAN_ERR_PROT_LOC_INTERM	error.h	76;"	d
CAN_ERR_PROT_LOC_RES0	error.h	68;"	d
CAN_ERR_PROT_LOC_RES1	error.h	67;"	d
CAN_ERR_PROT_LOC_RTR	error.h	66;"	d
CAN_ERR_PROT_LOC_SOF	error.h	58;"	d
CAN_ERR_PROT_LOC_SRTR	error.h	61;"	d
CAN_ERR_PROT_LOC_UNSPEC	error.h	57;"	d
CAN_ERR_PROT_OVERLOAD	error.h	52;"	d
CAN_ERR_PROT_STUFF	error.h	49;"	d
CAN_ERR_PROT_TX	error.h	54;"	d
CAN_ERR_PROT_UNSPEC	error.h	46;"	d
CAN_ERR_RESTARTED	error.h	28;"	d
CAN_ERR_TRX	error.h	24;"	d
CAN_ERR_TRX_CANH_NO_WIRE	error.h	81;"	d
CAN_ERR_TRX_CANH_SHORT_TO_BAT	error.h	82;"	d
CAN_ERR_TRX_CANH_SHORT_TO_GND	error.h	84;"	d
CAN_ERR_TRX_CANH_SHORT_TO_VCC	error.h	83;"	d
CAN_ERR_TRX_CANL_NO_WIRE	error.h	85;"	d
CAN_ERR_TRX_CANL_SHORT_TO_BAT	error.h	86;"	d
CAN_ERR_TRX_CANL_SHORT_TO_CANH	error.h	89;"	d
CAN_ERR_TRX_CANL_SHORT_TO_GND	error.h	88;"	d
CAN_ERR_TRX_CANL_SHORT_TO_VCC	error.h	87;"	d
CAN_ERR_TRX_UNSPEC	error.h	80;"	d
CAN_ERR_TX_TIMEOUT	error.h	20;"	d
CAN_FRAME_DATA_SIZE	IO_485.cpp	16;"	d	file:
CAN_FRAME_SIZE	IO_485.cpp	/^const int CAN_FRAME_SIZE = sizeof(struct can_frame);$/;"	v
CAN_H	can.h	16;"	d
CAN_INV_FILTER	can.h	123;"	d
CAN_ISOTP	can.h	83;"	d
CAN_MCNET	can.h	82;"	d
CAN_NETLINK_H	can_netlink.h	13;"	d
CAN_NPROTO	can.h	84;"	d
CAN_RAW	can.h	78;"	d
CAN_RAW_ERR_FILTER	can.h	/^	CAN_RAW_ERR_FILTER,	\/* set filter for error frames       *\/$/;"	e	enum:__anon3
CAN_RAW_FILTER	can.h	/^	CAN_RAW_FILTER = 1,	\/* set 0 .. n can_filter(s)          *\/$/;"	e	enum:__anon3
CAN_RAW_LOOPBACK	can.h	/^	CAN_RAW_LOOPBACK,	\/* local loopback (default:on)       *\/$/;"	e	enum:__anon3
CAN_RAW_RECV_OWN_MSGS	can.h	/^	CAN_RAW_RECV_OWN_MSGS	\/* receive my own msgs (default:off) *\/$/;"	e	enum:__anon3
CAN_RTR_FLAG	can.h	39;"	d
CAN_SFF_MASK	can.h	43;"	d
CAN_STATE_BUS_OFF	can_netlink.h	/^	CAN_STATE_BUS_OFF,		\/* RX\/TX error count >= 256 *\/$/;"	e	enum:can_state
CAN_STATE_ERROR_ACTIVE	can_netlink.h	/^	CAN_STATE_ERROR_ACTIVE = 0,	\/* RX\/TX error count < 96 *\/$/;"	e	enum:can_state
CAN_STATE_ERROR_PASSIVE	can_netlink.h	/^	CAN_STATE_ERROR_PASSIVE,	\/* RX\/TX error count < 256 *\/$/;"	e	enum:can_state
CAN_STATE_ERROR_WARNING	can_netlink.h	/^	CAN_STATE_ERROR_WARNING,	\/* RX\/TX error count < 128 *\/$/;"	e	enum:can_state
CAN_STATE_MAX	can_netlink.h	/^	CAN_STATE_MAX$/;"	e	enum:can_state
CAN_STATE_SLEEPING	can_netlink.h	/^	CAN_STATE_SLEEPING,		\/* Device is sleeping *\/$/;"	e	enum:can_state
CAN_STATE_STOPPED	can_netlink.h	/^	CAN_STATE_STOPPED,		\/* Device is stopped *\/$/;"	e	enum:can_state
CAN_TP16	can.h	80;"	d
CAN_TP20	can.h	81;"	d
CC	Makefile	/^CC=arm-none-linux-gnueabi-g++$/;"	m
CFLAGS	Makefile	/^CFLAGS= -g -Wall -O0 -fPIC$/;"	m
CSocketCAN	IO_485.cpp	/^CSocketCAN::CSocketCAN(void):m_FD(INVALID_FD),m_bActive(false)$/;"	f	class:CSocketCAN
CSocketCAN	IO_485.h	/^class  CSocketCAN:public IIOLayer,CThread$/;"	c
Close	IO_485.cpp	/^int CSocketCAN::Close( const char *args )$/;"	f	class:CSocketCAN
DEBUG	Makefile	/^DEBUG=-DNDEBUG$/;"	m
DEFAULT_CAN_INDEX	IO_485.cpp	18;"	d	file:
DLD	Makefile	/^DLD=-L\/usr\/local\/lib$/;"	m
DrvRun	IO_485.cpp	/^bool CSocketCAN::DrvRun()$/;"	f	class:CSocketCAN
ERR_DATA	IO_485.cpp	/^    const int ERR_DATA = -1;$/;"	v
Fini	IO_485.cpp	/^void CSocketCAN::Fini()$/;"	f	class:CSocketCAN
GetCoder	IO_485.cpp	/^ICoder * CSocketCAN::GetCoder()$/;"	f	class:CSocketCAN
IFLA_CAN_BERR_COUNTER	can_netlink.h	/^	IFLA_CAN_BERR_COUNTER,$/;"	e	enum:__anon4
IFLA_CAN_BITTIMING	can_netlink.h	/^	IFLA_CAN_BITTIMING,$/;"	e	enum:__anon4
IFLA_CAN_BITTIMING_CONST	can_netlink.h	/^	IFLA_CAN_BITTIMING_CONST,$/;"	e	enum:__anon4
IFLA_CAN_CLOCK	can_netlink.h	/^	IFLA_CAN_CLOCK,$/;"	e	enum:__anon4
IFLA_CAN_CTRLMODE	can_netlink.h	/^	IFLA_CAN_CTRLMODE,$/;"	e	enum:__anon4
IFLA_CAN_MAX	can_netlink.h	122;"	d
IFLA_CAN_RESTART	can_netlink.h	/^	IFLA_CAN_RESTART,$/;"	e	enum:__anon4
IFLA_CAN_RESTART_MS	can_netlink.h	/^	IFLA_CAN_RESTART_MS,$/;"	e	enum:__anon4
IFLA_CAN_STATE	can_netlink.h	/^	IFLA_CAN_STATE,$/;"	e	enum:__anon4
IFLA_CAN_UNSPEC	can_netlink.h	/^	IFLA_CAN_UNSPEC,$/;"	e	enum:__anon4
INCLUDE	Makefile	/^INCLUDE=-I.\/ -I\/usr\/local\/include -I..\/comm\/frame -I..\/comm\/sys$/;"	m
INVALID_FD	IO_485.cpp	12;"	d	file:
IOCtrl	IO_485.cpp	/^int CSocketCAN::IOCtrl( int nAction, void *pActionStruct, void *pRetData )$/;"	f	class:CSocketCAN
Init	IO_485.cpp	/^int CSocketCAN::Init( void *pMainServer )$/;"	f	class:CSocketCAN
InitSocketCAN	IO_485.cpp	/^bool CSocketCAN::InitSocketCAN()$/;"	f	class:CSocketCAN
LIBS	Makefile	/^LIBS=-lpthread -lrt -shared$/;"	m
MAX_CAN_BUF_LEN	IO_485.h	17;"	d
MAX_CAN_NAME	IO_485.h	16;"	d
MAX_SEND_COUNT	IO_485.cpp	/^const __UINT32 MAX_SEND_COUNT = 50;$/;"	v
NO_LEN	IO_485.cpp	/^    const int NO_LEN = 0;$/;"	v
OBJS	Makefile	/^OBJS=${SRC:.cpp=.o}$/;"	m
OnIOHandle	IO_485.cpp	/^void CSocketCAN::OnIOHandle( const int &IFIndex\/*½Ó¿ÚË÷Òý*\/ ,const char *pData,const int &nLen,const MSG_TYPE &type \/*= MSG_TYPE_DATA*\/ )$/;"	f	class:CSocketCAN
Open	IO_485.cpp	/^int CSocketCAN::Open( const char *args )$/;"	f	class:CSocketCAN
PF_CAN	can.h	28;"	d
Run	IO_485.cpp	/^void CSocketCAN::Run()$/;"	f	class:CSocketCAN
SOL_CAN_BASE	can.h	86;"	d
SOL_CAN_RAW	can.h	126;"	d
SRC	Makefile	/^SRC=..\/comm\/sys\/thread.cpp \\$/;"	m
SendMsg	IO_485.cpp	/^int CSocketCAN::SendMsg( const char *pData,const int &nSize )$/;"	f	class:CSocketCAN
Setopts	IO_485.cpp	/^void CSocketCAN::Setopts( int s, int loopback, int recv_own_msgs )$/;"	f	class:CSocketCAN
TARGET	Makefile	/^TARGET=IO_485.so$/;"	m
Write	IO_485.cpp	/^int CSocketCAN::Write( const char *pData,const int &nLen, const int &index \/*= 0*\/ )$/;"	f	class:CSocketCAN
__IFLA_CAN_MAX	can_netlink.h	/^	__IFLA_CAN_MAX$/;"	e	enum:__anon4
__s32	can.h	/^typedef __signed__ int __s32;$/;"	t
__s8	can.h	/^typedef __signed__ char __s8;$/;"	t
__u32	can.h	/^typedef unsigned int __u32;$/;"	t
__u8	can.h	/^typedef unsigned char __u8;$/;"	t
_socketcan_netlink_h	libsocketcan.h	22;"	d
arbitration_lost	can_netlink.h	/^	__u32 arbitration_lost; \/* Arbitration lost errors *\/$/;"	m	struct:can_device_stats
bitrate	can_netlink.h	/^	__u32 bitrate;		\/* Bit-rate in bits\/second *\/$/;"	m	struct:can_bittiming
brp	can_netlink.h	/^	__u32 brp;		\/* Bit-rate prescaler *\/$/;"	m	struct:can_bittiming
brp_inc	can_netlink.h	/^	__u32 brp_inc;$/;"	m	struct:can_bittiming_const
brp_max	can_netlink.h	/^	__u32 brp_max;$/;"	m	struct:can_bittiming_const
brp_min	can_netlink.h	/^	__u32 brp_min;		\/* Bit-rate prescaler *\/$/;"	m	struct:can_bittiming_const
bus_error	can_netlink.h	/^	__u32 bus_error;	\/* Bus errors *\/$/;"	m	struct:can_device_stats
bus_off	can_netlink.h	/^	__u32 bus_off;		\/* Changes to bus off state *\/$/;"	m	struct:can_device_stats
can_addr	can.h	/^	} can_addr;$/;"	m	struct:sockaddr_can	typeref:union:sockaddr_can::__anon1
can_berr_counter	can_netlink.h	/^struct can_berr_counter {$/;"	s
can_bittiming	can_netlink.h	/^struct can_bittiming {$/;"	s
can_bittiming_const	can_netlink.h	/^struct can_bittiming_const {$/;"	s
can_clock	can_netlink.h	/^struct can_clock {$/;"	s
can_ctrlmode	can_netlink.h	/^struct can_ctrlmode {$/;"	s
can_device_stats	can_netlink.h	/^struct can_device_stats {$/;"	s
can_dlc	can.h	/^	__u8    can_dlc; \/* data length code: 0 .. 8 *\/$/;"	m	struct:can_frame
can_err_mask_t	can.h	/^typedef __u32 can_err_mask_t;$/;"	t
can_family	can.h	/^	sa_family_t can_family;$/;"	m	struct:sockaddr_can
can_filter	can.h	/^struct can_filter {$/;"	s
can_frame	can.h	/^struct can_frame {$/;"	s
can_id	can.h	/^	canid_t can_id;  \/* 32 bit CAN_ID + EFF\/RTR\/ERR flags *\/$/;"	m	struct:can_frame
can_id	can.h	/^	canid_t can_id;$/;"	m	struct:can_filter
can_ifindex	can.h	/^	int         can_ifindex;$/;"	m	struct:sockaddr_can
can_mask	can.h	/^	canid_t can_mask;$/;"	m	struct:can_filter
can_state	can_netlink.h	/^enum can_state {$/;"	g
canid_t	can.h	/^typedef __u32 canid_t;$/;"	t
data	can.h	/^	__u8    data[8] __attribute__((aligned(8)));$/;"	m	struct:can_frame
error_passive	can_netlink.h	/^	__u32 error_passive;	\/* Changes to error passive state *\/$/;"	m	struct:can_device_stats
error_warning	can_netlink.h	/^	__u32 error_warning;	\/* Changes to error warning state *\/$/;"	m	struct:can_device_stats
flags	can_netlink.h	/^	__u32 flags;$/;"	m	struct:can_ctrlmode
freq	can_netlink.h	/^	__u32 freq;		\/* CAN system clock frequency in Hz *\/$/;"	m	struct:can_clock
m_Exit	IO_485.h	/^    CSignal m_Exit;$/;"	m	class:CSocketCAN
m_FD	IO_485.h	/^    int     m_FD;$/;"	m	class:CSocketCAN
m_bActive	IO_485.h	/^    bool    m_bActive;$/;"	m	class:CSocketCAN
m_nLogicCount	IO_485.h	/^    unsigned int m_nLogicCount;$/;"	m	class:CSocketCAN
m_pCoder	IO_485.h	/^    ICoder  *m_pCoder;$/;"	m	class:CSocketCAN
m_pMainServer	IO_485.h	/^    IMainInterface *m_pMainServer;$/;"	m	class:CSocketCAN
m_szName	IO_485.h	/^    char    m_szName[MAX_CAN_NAME];$/;"	m	class:CSocketCAN
mask	can_netlink.h	/^	__u32 mask;$/;"	m	struct:can_ctrlmode
max	IO_485.cpp	22;"	d	file:
min	IO_485.cpp	23;"	d	file:
name	can_netlink.h	/^	char name[16];		\/* Name of the CAN controller hardware *\/$/;"	m	struct:can_bittiming_const
pLogic	IO_485.h	/^    ILogic **pLogic;$/;"	m	class:CSocketCAN
phase_seg1	can_netlink.h	/^	__u32 phase_seg1;	\/* Phase buffer segment 1 in TQs *\/$/;"	m	struct:can_bittiming
phase_seg2	can_netlink.h	/^	__u32 phase_seg2;	\/* Phase buffer segment 2 in TQs *\/$/;"	m	struct:can_bittiming
prop_seg	can_netlink.h	/^	__u32 prop_seg;		\/* Propagation segment in TQs *\/$/;"	m	struct:can_bittiming
restarts	can_netlink.h	/^	__u32 restarts;		\/* CAN controller re-starts *\/$/;"	m	struct:can_device_stats
rx_id	can.h	/^		struct { canid_t rx_id, tx_id; } tp;$/;"	m	struct:sockaddr_can::__anon1::__anon2
rxerr	can_netlink.h	/^	__u16 rxerr;$/;"	m	struct:can_berr_counter
sample_point	can_netlink.h	/^	__u32 sample_point;	\/* Sample point in one-tenth of a percent *\/$/;"	m	struct:can_bittiming
sjw	can_netlink.h	/^	__u32 sjw;		\/* Synchronisation jump width in TQs *\/$/;"	m	struct:can_bittiming
sjw_max	can_netlink.h	/^	__u32 sjw_max;		\/* Synchronisation jump width *\/$/;"	m	struct:can_bittiming_const
sockaddr_can	can.h	/^struct sockaddr_can {$/;"	s
tp	can.h	/^		struct { canid_t rx_id, tx_id; } tp;$/;"	m	union:sockaddr_can::__anon1	typeref:struct:sockaddr_can::__anon1::__anon2
tq	can_netlink.h	/^	__u32 tq;		\/* Time quanta (TQ) in nanoseconds *\/$/;"	m	struct:can_bittiming
tseg1_max	can_netlink.h	/^	__u32 tseg1_max;$/;"	m	struct:can_bittiming_const
tseg1_min	can_netlink.h	/^	__u32 tseg1_min;	\/* Time segement 1 = prop_seg + phase_seg1 *\/$/;"	m	struct:can_bittiming_const
tseg2_max	can_netlink.h	/^	__u32 tseg2_max;$/;"	m	struct:can_bittiming_const
tseg2_min	can_netlink.h	/^	__u32 tseg2_min;	\/* Time segement 2 = phase_seg2 *\/$/;"	m	struct:can_bittiming_const
tx_id	can.h	/^		struct { canid_t rx_id, tx_id; } tp;$/;"	m	struct:sockaddr_can::__anon1::__anon2
txerr	can_netlink.h	/^	__u16 txerr;$/;"	m	struct:can_berr_counter
~CSocketCAN	IO_485.cpp	/^CSocketCAN::~CSocketCAN(void)$/;"	f	class:CSocketCAN
